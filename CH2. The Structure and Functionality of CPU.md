# CH2. CPU와 구조와 기능

**CPU의 기능**

- 모든 명령어에 대하여 공통적으로 수행

(1) **명령어 인출(instruction fetch)**: 기억장치로부터 명령어를 하나씩 읽어온다.

(2) **명령어 해독(instruction decode)**: 수행할 동작을 결정하기 위하여 명령어를 해독

- 명령어에 따라 필요한 경우에만 수행

(3) **데이터 인출(data fetch)**: 명령어 실행을 위해 데이터가 필요할 경우, 기억장치 혹은 I/O 장치로부터 데이터를 읽어옴

(4) **데이터 처리(data process)**: 데이터에 산술적/논리적 연산 수행

(5) **데이터 저장(data store)**: 연산을 수행한 결과를 저장



**2.1 CPU의 기본 구조**

- **산술논리연산장치(Arithmetic and Logical Unit, ALU)**: 산술/논리 연산을 수행하는 회로들로 이루어진 하드웨어 모듈
- **레지스터 세트(register set)**: 레지스터의 집합
  - **레지스터(register)**: CPU 내부의 일시적인 기억장치. 
    - 액세스 속도가 빠르다. 
    - 적은 수의 레지스터(특수 목적용과 적은 수의 일반 목적용 레지스터)
- **제어 유닛(control unit)**:프로그램 코드(명령어)를 해석하고 실행하기 위한 제어 신호(control signs)를 순차적으로 발생시키는 하드웨어 모듈
- CPU 내부 버스(CPU internal bus): (1) ALU와 레지스터들 간의 데이터 이동을 위한 데이터/주소 선들, (2)제어 유닛으로부터 발생되는 제어 신호들을 전송하는 선들로 구성
  - CPU 내부의 버퍼 레지스터(MBR, MAR) 혹은 인터페이스 회로를 통해 CPU 외부의 시스템 버스와 접속한다.



**2.2 명령어 실행**

- **명령어 사이클(instruction cycle)**: <u>한 개의 명령어</u>를 실행하는 데 필요한 과정.
  - CPU가 프로그램을 실행한 순간부터 (1) 전원을 끄거나 (2) 회복 불가능한 오류가 발생하여 중단될 때까지 반복
- 두 개의 서브사이클(subcycle)로 구성 
  - (1) **명령어 인출(instruction fetch)** 사이클 : CPU가 기억장치로부터 명령어를 읽어옴
  - (2) **명령어 실행(instruction execution)** 사이클: 인출된 명령어를 실행



**명령어 실행에 필요한 CPU 내부 레지스터**

- **PC(Program Counter, 프로그램 카운터)**: <u>다음에 인출할 명령어의 주소</u>를 가지고 있는 레지스터.
  - 명령어 인출 후에 자동으로 일정 크기가 증가.
  - 분기(branch) 명령어가 실행되는 경우 해당 목적지 주소로 갱신
- **ACC(Accumulator, 누산기)**: 데이터를 일시적으로 저장하는 레지스터.
  - 레지스터의 비트 수: CPU가 한 번에 연산 처리할 수 있는 데이터 비트의 수(단어 길이)와 같음
- **IR(Instruction Register, 명령어 레지스터)**: 기억장치에서 CPU로 <u>가장 최근에 인출된 명령어</u>가 저장된 레지스터
- **MAR(Memory Address Register, 기억장치 주소 레지스터)**: PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전 일시적으로 저장되어있는 주소 레지스터. CPU 외부의 버스와 직접적으로 연결됨.
- **MBR(Memory Buffer(Data) Register, 기억장치 버퍼 레지스터)**: 기억장치로부터 읽거나 그것에 쓸 데이터를 일시적으로 저장하는 버퍼 레지스터. CPU 외부의 버스와 직접적으로 연결됨.



**2.2.1 명령어 인출 사이클**

- **인출 사이클(fetch cycle)**: CPU가 기억장치의 지정된 주소로부터 명령어를 읽어오는 과정
- **마이크로 연산(micro-operation)**: CPU clock의 각 주기 동안 수행동되는 동작

$$
\begin{align*}
t_0&:\mathrm{MAR\leftarrow PC} \\
t_1&:\mathrm{MBR\leftarrow M[MAR], PC\leftarrow PC+1} \\
t_2&:\mathrm{IR\leftarrow MBR}
\end{align*}
$$

- (예 )인출 사이클 소요 시간 계산
  - CPU의 클록 주파수: 1GHz=$10^9$
  - 클록 주기: 1ns=1/1GHz=$10^{-9}$
  - 인출 사이클: 1ns * 3 = 3ns



**2.2.2 명령어 실행 사이클**

- **실행 사이클(execution cycle)**: CPU가 인출된 명령어 코드를 해독(decode)하고, 그 결과에 따른 연산을 수행함.
- CPU가 수행하는 연산
  - **데이터 이동**: CPU와 기억장치 혹은 I/O 장치 간 데이터 이동
  - **데이터 처리**: 데이터에 대한 산술/논리 연산 실행
  - **데이터 저장**: 연산의 결과 데이터 혹은 입력장치로부터 읽어들인 데이터를 기억장치에 저장
  - **프로그램 제어**: 프로그램의 실행 순서를 결정



- $\mathrm{LOAD\ }addr$: 기억장치의 데이터를 AC로 적재(load)

$$
\begin{align*}
t_0&:\mathrm{MAR\leftarrow IR(addr)}\\
t_1&:\mathrm{MBR\leftarrow M[MAR]} \\
t_2&:\mathrm{AC\leftarrow MBR}
\end{align*}
$$

- $\mathrm{STR}\ addr$: AC의 데이터를 기억장치에 저장

$$
\begin{align*}
t_0&:\mathrm{MAR\leftarrow IR(addr)}\\
t_1&:\mathrm{MBR\leftarrow AC}\\
t_2&:\mathrm{M[MAR]\leftarrow MBR}
\end{align*}
$$

- $\mathrm{Add\ }addr$: 기억장치의 데이터를 AC의 데이터와 더하고, 그 결과를 AC에 저장

$$
\begin{align*}
t_0&:\mathrm{MAR\leftarrow IR(addr)}\\
t_1&:\mathrm{MBR\leftarrow M[MAR]}\\
t_2&:\mathrm{AC\leftarrow AC+MBR}
\end{align*}
$$

- $\mathrm{JUMP\ }addr$: 분기 명령어. PC의 내용을 바꾸어 다른 위치의 명령어로 실행 순서를 바꿈.

$$
t_0:\mathrm{PC\leftarrow IR}(addr)
$$



**2.2.3 인터럽트 사이클**

- **인터럽트(interrupt)**: <u>순차적인 명령어 실행을 중단하고 다른 동작</u>을 수행하도록 하는 시스템 동작
  - CPU와 외부장치들 간의 상호작용을 위해 필요한 기능
- **인터럽트 서비스 루틴(Interrupt Service Routine, ISR)**: (1) 외부로부터 인터럽트 요구가 들어오면, (2) CPU는 원래의 프로그램을 수행을 중단하고(<u>현재 실행하고 있는 명령어는 마저 실행한다</u>) (3) 요구된 인터럽트를 처리하기 위한 프로그램을 수행(= 해당 ISR 수행) (4) 인터럽트에 대한 처리가 끝나면 원래의 프로그램으로 복귀한다.
- **인터럽트 사이클(interrupe cycle)**: (1) 인터럽트 요구 신호 검사 (2) 현재 PC의 내용 스택에 저장 (3) PC에 해당 ISR의 시작 주소를 적재
- 인터럽트 시작 전 인터럽트 가능 상태(interrupt enabled)를 검사한다.
- **스택 포인터(Stack Pointer, SP)**: CPU 내부의 특수 목적용 레지스터. 항상 스택의 최상위 주소를 가리킨다. 일반적으로 주기억장치의 끝 부분이 스택으로 사용된다.

$$
\begin{align*}
t_0&:\mathrm{MBR\leftarrow PC}\\
t_1&:\mathrm{MAR\leftarrow SP,\ PC\leftarrow ISR의\ 시작\ 주소}\\
t_2&:\mathrm{M[MAR]\leftarrow MBR,\ SP\leftarrow SP-1}
\end{align*}
$$



**다중 인터럽트(multiple interrupt)**

- 다중 인터럽트: ISR를 수행하는 도중 다른 장치의 ISR이 발생하는 것
- 다중 인터럽트의 처리 방법
  - (1) 다른 ISR 실행하지 않기: interrupt disabled 상태일 때는 CPU가 인터럽트 요구 신호를 검사하지 않도록 함. interrupt enabled 상태가 되면 인식됨.
  - (2) 인터럽트 요구 간 우선순위 정하기: 우선순위가 더 높은 인터럽트 요구가 들어오면 수행하고 있는 ISR 멈추고 새로운 ISR 처리함.



**2.2.4 간접 사이클(indirect cycle)**

- **간접 사이클**: 명령어에 적힌 주소가 [연산에 사용할 데이터의 주소]가 저장된 메모리의 주소를 가리킬 경우, [연산에 사용할 데이터의 주소]를 인출하는 사이클. 인출 사이클과 실행 사이클 사이에 위치한다.

$$
\begin{align*}
t_0&:\mathrm{MAR\leftarrow IR}(addr)\\
t_1&:\mathrm{MBR\leftarrow M[MAR]}\\
t_2&:\mathrm{IR}(addr)\mathrm{\leftarrow MBR}
\end{align*}
$$

- 간접 주소지정 방식(indirect addressing mode)에서 사용



**2.3 명령어 파이프라이닝(instrction pipelining)**

- **명령어 파이프라이닝(instrction pipelining)**: CPU의 성능 향상을 위하여, (1) 명령어를 실행하는 데 사용하는 하드웨어를 여러 개의 독립적인 단계로 분할하고 (2) 이것들이 동시에 서로 다른 명령어를 처리하도록 함.



**2.3.2 4-단계 명령어 파이프라인**

- 파이프라이닝의 효율을 위하여: <u>각 단계의 처리시간은 동일해야하고</u>, 그렇게 하려면 단계의 수를 늘리고 가장 오래 걸리는 단계의 처리시간으로 맞추어야함.
- (1) **명령어 인출(IF)** 단계: 기억장치로부터 다음 명령어를 인출함.
- (2) **명령어 해독(ID)** 단계: 해독기(decoder)로 명령어를 해석함.
- (3) **오퍼랜드 인출(OF)** 단계: 기억장치로부터 오퍼랜드를 인출함.
- (4) **실행(EX)** 단계: 지정된 연산을 수행(하고, 결과를 저장함)함.



**명령어 파이프라이닝 실행 시간**

- 파이프라인 단계 수가 $k$개이고, 실행할 명령어들의 수가 $N$개이며 각 파이프라인 단계가 한 클럭 주기씩 걸린다고 가정한다.
- 파이프라인에 의한 전체 명령어 실행 시간($T_k$)

$$
T_k=k+(N-1)
$$

- 파이프라인하지 않은 전체 명령어 실행 시간($T_1$)

$$
T_1=k*N
$$

**파이프라인에 의한 속도 향상(speedup)**
$$
Sp=\frac{T_1}{T_k}=\frac{k*N}{k+(N-1)}
$$


**파이프라인의 효율 저하 요인들**

- 모든 명령어가 파이프라인 단계를 필요로 하지 않을 수 있다.
  - 예로, 오퍼랜드를 인출할 필요가 없는 명령어가 있다.
- 파이프라인의 클록은 처리 시간이 가장 오래 걸리는 단계를 기준으로 한다.
  - 처리 시간이 클록보다 클 경우 병목 현상이 발생한다.
  - 처리 시간이 클록보다 작은 경우 시간 효율이 좋지 않다.
- IF 단계와 OF 단계가 동시에 기억장치를 액세스하는 경우, 기억장치 충돌(memory conflict)가 일어나 지연이 발생한다.
- 조건 분기(conditional branch)가 실행될 경우, 미리 인출하여 파이프라인에서 처리되고 있던 명령어들이 무효화된다.



**분기 발생으로 인한 성능 저하를 최소화하는 방법들**

- **분기 예측(branch prediction)**
  - 정적: 분기가 일어날 지 예측하고 명령어를 인출하는 확률적 방법
  - 동적: 최근의 분기 결과(분기 역사표(branch history table))를 참조
- **분기 목적지 선인출(prefetch brach target)**
  - 조건 분기가 인식되면, 분기 명령어의 다음 명령어에 분기의 목적지 명령어도 함께 인출함.
- **루프 버퍼(loop buffer)** 사용: IF 단계에 포함된 고속 기억장치로, 가장 최근에 인출된 n개의 명령어를 순서대로 저장함.
- **지연 분기(delayed branch)**: 분기 명령어의 위치를 재배치하여 파이프라인의 성능을 개선



**2.4 명령어 세트(instruction set)**

- **명령어 세트(instruction set)**: CPU를 위해 정의되어 있는 명령어들의 집합
- 명령어 세트 설계를 위한 고려사항
  - 연산 종류(operation repertoire): CPU가 수행할 연산의 수(op 코드의 비트 수), 종류 및 복잡도
  - 데이터 형태(data type): 연산을 수행할 데이터들의 형태, 데이터의 길이(비트 수), 수의 표현 방식 등
  - 명령어 형식(instruction format): 명령어의 길이, 오퍼랜드 필드의 수와 길이 등
  - 주소지정 방식(addressing mode): 명령어에 오퍼랜드의 주소를 지정하는 방식



**2.4.1 연산의 종류**

- **데이터 전송**: 레지스터와 레지스터 간/레지스터와 기억장치 간/기억장치와 기억장치 간에 데이터를 이동
- **산술 연산**: + - / %
- **논리 연산**
- **입출력(I/O)**: CPU와 외부 장치 간의 데이터 이동
- **프로그램 제어**
  - 명령어 실행 순서를 변경하는 연산들
    - 분기(branch), 서브루틴 호출(subroutine call)



**2.4.2 명령어 형식**

- 명령어의 구성 요소
  - (1) **연산 코드**: 수행될 연산을 지정
  - (2) **오퍼랜드**: 연산을 수행하는 데 필요한 데이터 혹은 데이터의 주소. 데이터는 CPU 레지스터, 주기억장치, I/O 장치에 위치함.
  - (3) **다음 명령어 주소**: 분기/호출 명령어와 같이 실행 순서를 변경하는 경우 필요, 현재의 명령어 실행이 완료된 후 다음 명령어를 인출할 위치
- 명령어 형식(instruction format): 필드의 수, 배치 방식, 각 필드에 포함되는 비트 수를 정의한 것
- 필드(field): 명령어의 각 구성 요소들에 소요되는 비트들의 그룹.
- 명령어의 길이(비트 수) = CPU가 한 번에 처리할 수 있는 데이터(단어)의 길이



**명령어의 필드의 길이**

- 연산 코드 필드의 길이: 연산의 개수를 결정
  - $n$비트 $\rightarrow$ $2^n$개의 연산을 지정할 수 있다.
- 오퍼랜드 필드의 길이: 오퍼랜드의 범위를 결정
  - 오퍼랜드 필드가 저장할 수 있는 오퍼랜드의 종류
    - (1) **데이터**: 표현 가능한 수의 범위를 결정
    - (2) **기억장치 주소**: CPU가 오퍼랜드 인출을 위해 직접 주소를 지정할 수 있는 기억장치 용량 결정
    - (3) **레지스터 번호**: 데이터 저장에 사용될 수 있는 레지스터의 개수 결정



**오퍼랜드 수로 분류하는 명령어**

- (1) **1-주소 명령어**(one-address instruction): 한 개의 오퍼랜드를 포함하는 명령어. <u>다른 한 개의 오퍼랜드는 묵시적으로 $\mathrm{AC}$가 된다.</u>
  - $\mathrm{ADD\ X}\quad\mathrm{AC\leftarrow AC+M[X]}$ 
- (2) **2-주소 명령어**(two-address instruction): 두 개의 오퍼랜드를 포함하는 명령어.
  - $\mathrm{ADD\ R1,R2}\quad\mathrm{R1\leftarrow R1+R2}$
  - $\mathrm{MOV\ R1,R2}\quad\mathrm{R1\leftarrow R2}$
- (3) **3-주소 명령어**(three-address instruction): 세 개의 오퍼랜드를 포함하는 명령어.
  - $\mathrm{ADD\ R1,R2,R3}\quad\mathrm{R1\leftarrow R2+R3}$



**2.4.3 주소지정 방식(addressing mode)**

- **주소지정 방식**: 명령어 실행에 필요한 오퍼랜드의 유효 주소(effective address)를 지정하는 방식
- 다양한 주소지정방식을 사용하는 이유: 사용자가 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위함.
- 주소지정 방식의 종류
  - 직접 주소지정 방식(direct addressing mode)
  - 간접 주소지정 방식(indirect addressing mode)
  - 묵시적 주소지정 방식(implied addressing mode)
  - 즉시 주소지정 방식(immediate addressing mode)
  - 레지스터 주소지정 방식(register addressing mode)
  - 레지스터 간접 주소지정 방식(register-indirect addressing mode)
  - 변위 주소지정 방식(displacement addressing mode)
    - 상대 주소지정 방식(relative addressing mode)
    - 인덱스 주소지정 방식(indexed addressing mode)
    - 베이스-레지스터(base-register addressing mode)
- 주소지정 방식에 쓰이는 기호
  - $EA$: 유효 주소(effective address), 데이터가 저장된 기억장치의 실제 주소
  - $A$: 오퍼랜드 필드의 내용이 기억장치 주소인 경우
  - $R$: 오퍼랜드 필드의 내용이 레지스터 번호인 경우
  - $(A)$: 기억장치 $A$번지의 내용
  - $(R)$: 레지스터 $R$의 내용



**1) 직접 주소지정 방식**

- 직접 주소지정 방식: 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 방식

$$
EA=A
$$

- 장점: 데이터 인출을 위하여 단 한 번의 기억장치 액세스만 필요하다.
- 단점: 직접 액세스할 수 있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한된다.



**2) 간접 주소지정 방식**

- 간접 주소지정 방식: 오퍼랜드 필드가 <u>데이터의 유효 주소를 저장한</u> 기억장치의 주소를 저장함.

$$
EA=(A)
$$

- 명령어에 간접 비트($I$)가 저장: $I$비트가 0이면 직접 주소지정 방식, 1이면 간접 주소지정 방식
- 장점: 최대 기억장치 용량의 단어의 길이에 의하여 결정되므로, 주소 지정 가능한 기억장치의 용량이 확장된다.
- 단점: 실행 사이클 동안 두 번의 기억장치 액세스가 필요하다.
  - 첫번째 액세스: 주소 인출
  - 두번째 액세스: 인출한 주소의 기억장소로부터 실제 데이터 인출



**3) 묵시적 주소지정 방식**

- 묵시적 주소지정 방식: 명령어 실행에 필요한 데이터의 위치가 묵시적으로 지정된다.
  - $\mathrm{SHL}$: 누산기의 내용을 좌측으로 쉬프트
  - $\mathrm{PUSH\ R1}$: 레지스터 $\mathrm{R1}$의 내용을 스택에 저장한다.
- 장점: 명령어의 길이가 짧다.
- 단점: 종류가 제한된다.



**4) 즉시 주소지정 방식**

- 즉시 주소지정 방식: 오퍼랜드 필드가 실제로 연산에 사용할 데이터이다.
- 용도: 프로그램에서 레지스터나 변수의 초기값을 어떤 상수값(constant value)로 세트하는데 사용
- 장점: 데이터 인출을 위해 기억장치에 액세스할 필요가 없다.
- 단점: 상수값의 크기가 오퍼랜드 필드의 비트 수에 의해 제한된다.



**5) 레지스터 주소지정 방식**

- 레지스터 주소지정 방식: 오퍼랜드 필드가 레지스터 번호를 지정한다.

$$
EA=R
$$

- 주소지정에 사용할 수 있는 레지스터들의 수 = $2^k$
- 장점: 오퍼랜드 필드의 비트 수가 적어도 된다. 데이터 인출을 위해 기억장치 액세스할 필요가 없다(CPU 내부 레지스터이므로).
- 단점: 데이터가 저장될 수 있는 공간이 CPU 내부 레지스터로 제한된다.



**6) 레지스터 간접 주소지정 방식**

- 레지스터 간접 주소지정 방식: 오퍼랜드 필드가 <u>유효 주소를 저장한</u> 레지스터의 번호를 지정한다.

$$
EA=(R)
$$

- 장점: 주소 지정할 수 있는 기억장치 영역이 확장된다.
  - 레지스터 길이 = 16비트, 주소지정 영역 = $2^{16}$



**7) 변위 주소지정 방식**

- 직접 주소지정과 레지스터 간접 주소지정 방식의 조합
- <u>지정된 레지스터의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정</u>한다.
- 변위 주소지정 방식의 분류: 사용되는 레지스터에 따라 분류할 수 있다.
  - 상대 주소지정 방식: PC 사용
  - 인덱스 주소지정 방식: 인덱스 레지스터 사용
  - 베이스-레지스터 주소지정 방식 베이스 레지스터 사용



**7-1) 상대 주소지정 방식**

- 상대 주소지정 방식: PC의 내용과 변위 $A$를 더하여 유효 주소 결정

$$
EA=A+(PC)\quad{(A는\ 2의\ 보수)}
$$

- 주로 분기 명령어에 사용한다.
  - $A>0$: 앞으로 분기
  - $A<0$: 뒤로 분기
- 예: JUMP 명령어가 450번지에 저장되었고, 오퍼랜드 $A=21$일 때와 $A=-50$일 때, 각각 몇 번지로 점프하는가?
  - 명령어 인출 후 PC는 451로 증가하므로, 451 + 21
  - 같은 원리로, 451-50
- 장점: 일반적인 분기 명령어보다 적은 수의 비트가 필요하다.
- 단점: 분기 범위가 오퍼랜드 필드의 길이(로 표현가능한 2의 보수 범위)에 의해 제한된다.



**7-2) 인덱스 주소지정 방식**

- 인덱스 주소지정 방식: 인덱스 레지스터의 내용과 변위 $A$를 더하여 유효 주소 결정
  - 인덱스 레지스터($IX$): 인덱스 값을 저장하는 특수 목적 레지스터. 데이터 배열의 시작 주소로부터 각 데이터까지의 거리를 나타낸다.
  - 일반적으로 주소 $A$는 기억장치에 저장된 데이터 배열의 시작 주소를 가리킨다.

$$
EA=A+(IX)
$$

- **자동 인덱싱(auto-indexing)**: 명령어가 실행될 떄마다 인덱스 레지스터의 내용이 자동적으로 증감한다.
  - 자동 인덱싱이 사용된 명령어가 실행되면 아래의 두 연산이 연속적으로 실행된다.

$$
\begin{align*}
EA&=(IX)+A \\
IX&\leftarrow IX+1
\end{align*}
$$

**7-3) 베이스-레지스터 주소지정 방식**

- 베이스-레지스터 주소지정 방식: 베이스 레지스터의 내용과 변위 $A$를 더하여 유효 주소를 결정
  - 베이스-레지스터: 기준이 되는 명령어의 주소를 저장한다. 반면 인덱스 레지스터는 주소 $A$를 기준으로 한 인덱스 값이 저장된다.

$$
EA=(BR)+A
$$

- 용도: 프로그램의 위치 지정 혹은 변경에 사용된다.