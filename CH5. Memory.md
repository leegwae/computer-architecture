# CH5. Memory

- 프로그램과 데이터를 저장하는 장치
  - 주기억장치(main memory)
  - 보조저장장치(auxiliary storage device)



- **액세스 시간(access time)**: 주소와 쓰기/읽기 신호가 도착한 순간부터 데이터 액세스가 완료되는 순간까지의 시간

- **전송 단위(unit of transfer)**: CPU가 한 번의 기억장치 액세스에 의해 읽거나 쓸 수 있는 비트 수

  - 주기억장치: 단어(word) 단위
  - 보조저장장치: 블록(512 바이트 혹은 1K 바이트) 단위

- **기억장치시스템을 설계할 때 고려할 특성들**

  - (1) 용량(capacity)
  - (2) 액세스 속도

- **주소지정 단위(addressable unit)**: 주소가 지정된 각 기억 장소 당 저장되는 데이터 길이

  - <u>바이트</u> 단위 혹은 <u>단어</u> 단위
  - 주소 비트의 수 $A$, 주소지정 단위의 수 $N$과 의 관계: $2^A=N$

- **데이터 전송률(data transfer rate)**: 기억장치로부터 초당 액세스할 수 있는 비트 수

  - <u>(1/액세스 시간) X (한 번에 읽혀지는 데이터 비트 수)</u>

  - (예) 액세스 시간 = 100ns, 액세스 단위 = 32비트

    데이터 전송률 = (1/100ns) X 32 = 320[MBits/sec]



## 5.1 기억장치의 분류와 특성

- **기억장치 액세스(memory access)**: CPU가 어떤 정보를 기억장치에 쓰거나 기억장치로부터 읽는 동작



### 5.1.1 기억장치의 액세스 유형

- 보조저장장치의 액세스 방식
  - **순차적 액세스(sequential access)**: 기억장치에 저장된 정보를 처음부터 순서대로 액세스하는 방식.
    - (예) 자기 테이프
  - **직접 액세스(direct access)**: 읽기/쓰기 장치가 액세스할 위치 근처로 이동, 순차적 검색을 통하여 최종 위치에 도달하는 방식
    - (예) 디스크, CD-ROM, DVD
- 주기억장치의 액세스 방식
  - **임의 액세스(random access)**: 주소로 직접 기억 장소를 찾아 액세스, 어떤 기억 장소든 액세스하는 시간이 동일
    - (예) 반도체 기억장치, RAM, ROM
  - **연관 액세스(associative access)**: 저장된 내용의 특정 비트들(태그)을 비교, 일치하는 내용에 액세스
    - (예) 연관 기억장치(associative memory) - cache



### 5.1.2 기억장치의 유형

- 메모리
  - 반도체
    - 메인 메모리, RAM
    - ROM
  - 보조기억장치
    - 하드 디스크, CD-ROM



**제조 재료로 분류하기**
- **반도체 기억장치(semiconductor memory)**: 반도체 물질인 실리콘(Si) 칩을 이용한 기억장치
  - (예) RAM, ROM, 플래시 메모리
- **자기-표면 기억장치(magnetic-surface memory)**: 자화 물질로 코팅된 표면에 정보를 저장하는 기억장치
  - (예) 디스크



**데이터를 저장하는 성질로 분류하기**
- **휘발성 기억장치(volatile memory)**: 전원 공급이 중단되면 내용이 사라지는 기억장치
  - (예) RAM
- **비휘발성 기억장치(nonvolatile memory)**: 전원 공급에 관계없는 영구 저장장치
  - (예) ROM, 디스크, SSD



- **삭제 불가능 기억장치(non=erasable memory)**: 내용 변경이 불가능한 기억장치
  - (예) ROM



## 5.2 계층적 기억장치시스템

- 계층적 기억장치시스템(hierarchical memory system)
  - CPU 레지스터 - 캐시 - 주기억장치 - 하드 디스크 및 SSD - 자기 테이프 및 CD-ROM
- 기억장치의 분류
  - 내부 기억장치(internal memory) : CPU가 직접 액세스할 수 있음
    - (예) CPU 레지스터, 캐시, 주기억장치
  - 외부 기억장치(external memory): 장치 제어기(device contoller)를 통해 액세스할 수 있음
    - (예) 하드 디스크 및 SSD, 자기 테이프 및 CD-ROM



### 5.2.1 필요성 및 효과

- 계층화의 필요성: 기억장치들은 성능, 용량, 가격이 매우 다양하므로 적절히 구성하는 것이 필요
- 계층화의 효과: 기억장치 시스템의 성능 대 가격비(performance/cost ratio) 향상



**기억장치의 특성**

- 액세스 속도가 높아질수록, 비트당 가격은 높아진다.
- 용량이 커질수록, 비트당 가격은 낮아진다.
- 용량이 커질수록, 액세스 시간은 길어진다.



**게층적 기억장치시스템의 기본 구성 방법**

- 첫번째 계층 기억장치: 속도가 빠름. 가격은 높음.
- 두번째 계층 기억장치: 속도가 느림. 가격이 낮음.



**지역성의 원리**

- 기억장치의 액세스가 몇몇 특정 영역에 집중되는 현상
- 지역성의 원리에 의해, 첫번째 계층의 기억장치에 대한 액세스 횟수가 두번째 계층의 기억장치에 대한 액세스 횟수가 훨씬 더 많음.
- 계층적 기억장치시스템에서 지역성의 원리가 적용되는 경우, 평균 기억장치 액세스 시간이 단축됨.



### 5.2.2 기억장치 계층

- 상위 계층으로 올라갈수록 용량이 작아지고, 비트당 가격이 높아지고, 액세스 시간이 짧아지며 액세스 빈도가 높아진다.
- 하위 계층으로 내려갈수록 용량이 커지고, 비트당 가격이 떨어지며, 지역성의 원리로 인해 액세스 빈도가 낮아진다.



**캐시 메모리**

- 주기억장치의 액세스 속도는 CPU에 비하여 현저히 느리다.
- 즉, 주기억장치로부터 데이터를 읽어오는 동안 CPU가 오랫동안 기다려야한다.
- 성능 저하를 줄이기 위해, <u>CPU와 주기억장치 사이에 고속의 반도체 기억장치</u>를 설치한다.



**2-단계 계층적 기억장치**

- 첫번째 계층 기억장치는 저용량, 고속이며 두번째 계층 기억장치는 대용량, 저속이다.

- 첫번째 계층에 액세스하고, 없다면 두번째 계층에 액세스한다.

- (예) 첫번째 계층 액세스 시간 = 10ns, 두번째 계층 액세스 시간 = 100ns

  액세스할 정보가 첫번째 계층 기억장치에 있을 확률 = 50%

  평균 기억장치 액세스 시간 = (0.5 X 10ns) + (0.5 X 100ns) = 55ns



## 5.3 반도체 기억장치

### 5.3.1 RAM(Random Access Memory)

- 임의 액세스 방식을 사용
- 반도체 직접회로 기억장치(semiconductor IC memory)
- 데이터의 읽기/쓰기가 가능
- 휘발성(volatile)



**제조 기술에 따른 RAM 분류**

- (1) DRAM(Dynamic RAM)
  - capacitor에 전하(charge)를 충전하는 방식으로 데이터를 저장하는 기억 소자들(memory cells)로 구성 : 집적 밀도가 높음.
  - 데이터의 저장 상태를 유지하기 위해 주기적인 재충전(refresh) 필요
  - 직접 밀도가 더 높으며, 같은 용량의 SRAM보다 비트당 가격이 더 저렴.
  - 용량이 큰 주기억장치로 사용
- (2) RAM(Static RAM)
  - 기억 소자로서 플립-플롭(flip-flop)을 이용 : 직접 밀도가 낮음
  - 전력이 공급되는 동안 재충전 없이도 데이터 유지 가능
  - DRAM보다 더 빠름
  - 높은 속도가 필요한 캐시 메모리로 사용



**1K X 8  칩과 제어 신호들**

- 1K = 1024 = $2^{10}$
- 제어 신호들: 칩 선택 신호(CS), 읽기 신호(RD), 쓰기 신호(WR)
- 주소 버스: 10비트
- 데이터 버스: 8비트

| $CS$ | $RD$ | $WR$ | RAM의 동작    |
| ---- | ---- | ---- | ------------- |
| 0    | X    | X    | 선택되지 않음 |
| 1    | 1    | 0    | 읽기 동작     |
| 1    | 0    | 1    | 쓰기 동작     |



**64-bit RAM의 내부 조직 예시들**

(1) 8 X 8 비트 조직

- $2^3$ X 8 : 주소 비트의 수(주소 버스의 폭) = 3, 데이터 입출력 선의 수(데이터 버스의 폭) = 8
- 주소 버스로부터 3비트 주소 - 3X8 해독기 - 8개의 8비트 기억장소 - 데이터 버스로 8비트 주소
- 용량에 따른 주소 비트수
  - 8Kbit RAM: 1K X 8비트 조직인 경우, 1K = $2^{10}$이므로 주소 = 10비트 필요
  - 1Mbit RAM: 128K X 8비트 조직인 경우, 1K = $2^{10}$, 128 = $2^7$이므로 주소 = 17비트 필요
  - 1Gbit RAM: 128M X 8비트 조직인 경우, 1M = K X K = $2^{10}$ X $2^{10}$, 128 = $2^7$이므로 주소 = 27비트 필요



(2) 16 X 4 비트 조직

- $2^4$ X 4 : 주소 비트의 수 = 4, 데이터 입출력 선의 수 = 4
- 주소 버스로부터 4비트 주소 - 4X16 해독기 - 16개의 4비트 기억장소 - 데이터 버스로 4비트 주소
- 용량에 따른 주소 비트수
  - 8Kbit RAM: 2K X 4비트 조직인 경우, 1K = $2^{10}$, 2 = $2^1$이므로 주소 = 11비트 필요
  - 1Mbit RAM: 256K X 4비트 조직인 경우, 1K = $2^{10}$, 256 = $2^8$이므로 주소 = 18비트 필요
  - 1Gbit RAM: 256M X 4비트 조직인 경우, 1M = K X K = $2^{10}$ X $2^{10}$, 256 = $2^8$이므로 주소 = 28비트 필요



(3) 64 X 1 비트 조직

- $2^6$ X 4 : 주소 비트의 수 = 6, 데이터 입출력 선의 수 = 1
- 상위 3비트 - 8개의 행 중 하나, 하위 3비트 - 8개의 열 중 하나
- 주소 버스로부터 6비트 - 두 개의 3X8 해독기 - 64개의 1비트 기억장소 - 데이터 버스로 1비트 주소
- 용량에 따른 주소 비트수
  - 8Kbit RAM: 8K X 1비트 조직인 경우, 1K = $2^{10}$, 8 = $2^3$이므로 주소 = 13비트 필요
  - 1Mbit RAM: 1M X 1비트 조직인 경우, 1M = K X K = $2^{10}$ X $2^{10}$이므로 주소 = 20비트 필요
  - 1Gbit RAM: 1G X 1비트 조직인 경우, 1G = K X K X K = $2^{10}$ X $2^{10}$ X $2^{10}$이므로 주소 = 30비트 필요



(4) 16M X 4 비트 조직

- 16M=$2^4$X K X K = $2^4$ X $2^{10}$ X $2^{10}$ = $2^{24}$
- $2^{24}$ X 4 : 주소 비트의 수 = 24, 데이터 입출력 선의 수 = 1
  - RAS(Row Address Strobe) 신호와 CAS(Column Address Strobe) 신호를 이용, 칩으로 실제 입력되는 주소 비트의 수는 12
- $2^{12}$=4096개의 열과 4097개의 행. 각각의 칸에는 4비트 기억장소

- 주소 버스로부터 24비트 - 해독기들 - 16M=$2^{24}$개의 4비트 기억장소 - 데이터 버스로 4비트 주소



### 5.3.2 ROM(Read Only Memory)

- 저장된 내용을 읽는 것만 가능한 반도체 기억장치
- 영구 저장이 가능함. 비휘발성
- 다음과 같은 내용을 저장한다.
  - 시스템 초기화 및 진단 프로그램(BIOS 프로그램: 가장 기본적인 I/O 처리)
  - 자주 사용되는 함수들을 위한 서브루틴들
  - 제어 유닛의 마이크로프로그램
- 64K X 8 비트 조직의 ROM 구성
  - $RD$: 읽기 신호
  - $CS$:  칩 선택 신호
  - 주소 버스: 16비트
  - 데이터 버스: 비트



**ROM의 종류**

- ROM(Prgarmmable ROM): 사용자가 한 번은 쓰는 것이 가능한 ROM
- EPROM: 자외선을 이용하여 내용을 지우는 PROM. 여러 번 쓰기가 가능
- EEPROM(Electrically Erasable PROM): 전기적으로 지울 수 있는 EPROM. 데이터 갱신 횟수가 수만 번으로 제한.
- 플래시 메모리(flash memory): (예) USB 
  - NAND형: 페이지 단위(2/4KB) 읽기/쓰기, 블록 단위(64/128 페이지) 단위 삭제 가능
  - NOR형: 바이트 단위 읽기/쓰기 가능
  - EEPROM에 비해 삭제 시간이 더 빠르고 집적 밀도가 더 높음.
  - 삭제 횟수가 제한 되어 있음. (10^5~10^6)
  - 하드 디스크를 대체하는 SSD(solid state disk)의 구성요소



## 5.4 기억장치 모듈의 설계

### 5.4.1 기억장치 칩의 병렬접속과 직렬접속

**기억장치 칩의 데이터 I/O 비트 수가 단어 길이보다 적은 경우** 

- 여러 개의 칩들을 <u>병렬접속</u>하는 기억장치 모듈을 구성
- 단어의 길이 = N 비트, 기억 장치 칩의 데이터 I/O 비트 수 = B : N/B 개의 칩들을 병렬 접속



(1) 6 X 4비트 RAM 칩들로 16 X 8비트 기억장치 모듈 구성하기

- 방법: 8 / 4 = 2개의 RAM 칩들 병렬 접속
- 모듈의 용량: (16 X 4) X 2 = 16 X 8비트 = 16바이트
- 주소 비트(4개: $A_3$~$A_0$): 두 칩들에 공통으로 접속
- 칩 선택(CS) 신호: 두 칩들에 공통으로 접속
- 주소 영역: $0000_2$~$1111_2$



(2) 1K X 8비트 RAM 칩들로 1K X 32비트 기억장치 모듈 구성하기

- 방법: 32 / 8 = 4개의 RAM 칩들 병렬 접속
- 모듈의 용량: (1K X 8) X 4 = 1K X 32비트 = 1Kword 
- 주소 비트(10개: $A_9$~$A_0$): 모든 칩들에 공통으로 접속
- 주소 영역: $000H$~$3FFH$
- 데이터 저장: 동일한 기억장치 주소에 대해 칩 당 하위 8비트씩 분산 저장



**필요한 기억 장치의 수가 각 기억장치 칩의 기억 장소 수보다 많은 경우**

- 여러 개의 칩들을 <u>직렬접속</u>하여 기억장치 모듈을 구성



(1) 두 개의 16 X 4비트 칩들로 32 X 4비트 기억장치 모듈 구성하기

- 방법: 2개의 RAM 칩들을 직렬 접속
- 모듈의 용량: 2개 X (16 X 4) = 32 X4비트
- 주소 비트(5개: $A_4$~ $A_0$)
  - $A_4$: 칩 선택 신호로 사용
  - $A_3$~$A_0$: 두 칩들에 공통으로 접속
- 주소 영역: 최상위 비트가 0이면 RAM1, 1이면 RAM2
  - RAM1: 00000 ~ $01111_2$
  - RAM2: 10000 ~ $11111_2$



(2) 1K X 8 비트 칩들로 4K X 8 비트 기억장치 모듈 구성하기

- 방법: 4개의 RAM 칩들을 직렬 접속
- 모듈의 용량: (1K X 8) X 4 = 4K X 8비트 = 4KByte
- 주소 비트(12개: $A_{11}$~ $A_0$)
  - 상위 2비트($A_{11}$, $A_{10}$): 주소 해독기를 이용하여 네 개의 칩 선택(CS) 신호 발생
  - 하위 10비트($A_{9}$~ $A_0$): 모든 집들에 공통으로 접속
- 전체 주소 영역: 000H ~ FFFH
  - RAM1: 000H ~ 3FFH
  - RAM2: 400H ~ 7FFH
  - RAM3: 800H ~ BFFH
  - RAM4: C00H ~ FFFH
- 데이터 버스: 모든 기억 장치 칩에 공통 접속 => 한 번에 8비트씩 액세스



### 5.4.2 기억장치 모듈의 설계 순서

- 컴퓨터 시스템에 필요한 <u>기억장치의 용량</u>을 결정한다.
- <u>사용할 칩들을 결정</u>하고, <u>주소 표</u>(address table; address map)<u>를 작성</u>한다.
- <u>세부 회로를 설계</u>한다.



(예) 8-비트 마이크로컴퓨터를 위한 기억장치의 설계

- 주기억장치 용량: 1KByte(1K X 8비트) ROM, 2KByte RAM(2K X 8비트)
- 주소 영역: ROM=0번지부터, RAM=800H번지부터
- 사용가능한 칩들: 1K X B비트 ROM, 512 X 8비트 RAM들
  - => 주소공간확장을 위해 직렬접속: 4 X $2^9$ X 8비트
- 기억장치 주소 표(memory address map)
  - $A_{11}$~$A_{10}$: 2 X 4 해독기 사용
  - $A_{9}$~$A_{0}$: RAM - address line, 9개

| 기억장치 칩 | 주소 영역(16진수) | 주소비트들($A_{11}$ ~ $A_{0}$)          |
| ----------- | ----------------- | --------------------------------------- |
| ROM         | 000H~3FFH         | 0  0  X  X    X  X  X  X     X  X  X  X |
| RAM1        | 800H~9FFH         | 1  0  0  X    X  X  X  X     X  X  X  X |
| RAM2        | A00H~BFFH         | 1  0  1  X    X  X  X  X     X  X  X  X |
| RAM3        | C00H~DFFH         | 1  1  0  X    X  X  X  X     X  X  X  X |
| RAM4        | E00H~FFFH         | 1  1  1  X    X  X  X  X     X  X  X  X |



## 5.5 캐시 메모리(Cache Memory)

- 사용하는 이유: CPU와 주기억장치의 속도 차이로 인해 CPU가 대기하는 시간을 최소화하기 위해 CPU와 주기억장치 사이에 설치하는 고속 반도체 기억장치
- "on chip cache": CPU 내부에 설치된 캐시 메모리
- 캐시 메모리의 특징
  - 주기억장치(DRAM)보다 액세스 속도가 더 높은 칩(SRAM; 플립 플립이라 빠름)을 사용
  - 가격 및 제하뇐 공간 때문에 용량이 작음.



### 5.1 데이터가 캐시 안에 있는가?

- **캐시 적중(cache hit)**: CPU가 원하는 데이터가 캐시에 있는 상태
- **캐시 미스(cache miss)**: CPU가 원하는 데이터가 캐시에 없는 상태. 이때 주기억장치로부터 데이터를 읽어온다.
- **적중률(hit ratio)**: 캐시가 적중하는 정도($H$)

$$
H=\frac{캐시에\ 적중되는\ 횟수}{전체\ 기억장치\ 액세스\ 횟수}
$$

- 캐시의 미스율(miss ratio): $1-H$
- 평균 기억장치 액세스 시간($Ta$)

$$
Ta=H \times Tc + (1-H)\times Tm
$$

$Tc$는 캐시 액세스 시간, $Tm$은 주기억장치 액세스 시간



**캐시 적중률과 평균 기억장치 액세스 시간의 관계**

- 캐시 적중률이 높아질수록 평균 기억장치 액세스시간은 캐시 액세스 시간에 근접
- 캐시 적중률은 프로그램과 데이터의 지역성(locality)에 따라 달라짐.



### 5.2 지역성(locality)

- **시간적 지역성(temporal locality)**: 최근에 액세스된 프로그램이나 데이터가 <u>가까운 미래에 다시 액세스 될 가능성</u>이 높다.
- **공간적 지역성(spatial locality)**: 기억장치 내에 인접하여 저장된 데이터들이 <u>연속적으로 액세스 될 가능성</u>이 높다.
- **순차적 지역성(sequantial locality)**: 분기(branch)가 발생하지 않는 한, 명령어들은 <u>기억장치에 저장된 순서대로 인출되어 실행</u>된다.



### 5.3 캐시 설계

**캐시 설계의 공통적인 목표**

- 캐시 <u>적중률의 극대화</u>
- 캐시 <u>액세스 시간의 최소화</u>
- 캐시 미스에 따른 <u>지연 시간의 최소화</u>
- 주기억장치와 캐시 간의 <u>데이터 일관성 유지</u> 및 <u>그에 따른 오버헤드의 최소화</u>



**목표를 달성하기 위한 설계상의 문제들**

- (1) 캐시의 크기(용량)
  - 용량이 커질수록 적중률이 높아진다. 그러나 비용이 증가한다.
  - 용량이 커질수록 (주소 해독, 정보 인출을 위한) 주변 회로가 더 복잡해지므로 액세스 시간이 다소 더 길어진다.
- (2) 인출 방식
  - **요구 인출(demand fetch)**: <u>필요한 정보만</u> 인출하는 방법
  - **선인출(prefetch)**: <u>필요할 것으로 예측되는 정보도</u> 미리 인출하는 방법
    - <u>지역성이 높은 경우</u> 적중률이 높아진다.
- (3) 사상 방식(mapping): 각 주기억장치 블록(K개의 단어)이 어느 캐시 라인(==slot)에 적재될 것인지 결정해주는 방식, 캐시 내부 조직을 결정
  - 완전-연관 사상(full-associative mapping)
  - 직접 사상(direct mapping)
  - 세트-연관 사상(set-associative mapping)



### 5.4 사상 방식

**완전-연관 사상**(full-associative mapping)

- 주기억장치 블록이 캐시의 어떤 라인으로든 적재 가능
- 태그 필드 = 주기억장치 블록 번호
- 기억장치 주소 형식: [ 태그 필드 | 단어 필드 ]
- 캐시 미스 시 버퍼에 저장한 주소를 메인 메모리로 보냄
- 장점
  - 새로운 블록을 적재할 때 캐시 라인의 선택이 매우 자유롭다.
  - 지역성이 높으면 적중률이 매우 높아진다.
- 단점: 캐시 라인들의 태그를 병렬로 검사하기 위해 가격이 높은 연관 기억장치(associative memory) 및 복잡한 주변 회로가 필요



**직접 사상**(direct mapping)

- 주기억장치 블록이 지정된 하나의 캐시 라인으로만 적재됨
- 기억장치 주소 형식: [ 태그 필드($t$) | 라인 필드($l$) | 단어 필드($w$) ]
  - 태그 필드($t$ 비트): 태그 번호(라인에 적재되어 있는 블록의 번호)
  - 라인 번호($l$ 비트): 캐시의 $m=2^l$개의 라인들 중의 하나를 지정
  - 단어 필드($w$ 비트): 각 블록 내 $2^w$개 단어들 중 하나를 구분
- 주기억장치 블록이 적재될 수 있는 캐시 라인의 번호

$$
i=j\ mod\ m\quad(i:캐시\ 라인\ 번호,\ j:주기억장치\ 블록\ 번호,\ m:캐시\ 라인의\ 전체\ 수)
$$

- 장점: 하드웨어가 간단하고, 구현 비용이 적게 든다.
- 단점: 각 주기억장치 블록이 적재될 수 있는 캐시 라인이 한 개 뿐이므로 그 라인을 공유하는 다른 블록이 적재되는 경우 overwrite되거나 swap-out된다.



**세트-연관 사상**(set-associative mapping)

- 직접 사상과 완전-연관 사상의 조합
- 주기억장치 블록 그룹이 하나의 캐시 세트를 공유하고, 세트에는 두 개 이상의 라인이 적재될 수 있음.
- 캐시: $v$개의 세트들 => 각 세트들은 $k$개의 라인들로 구성
- 기억장치 주소 형식: [ 태그 필드($t$) | 세트 필드($s$) | 단어 필드($w$) ]
- 주기억장치 블록이 적재될 수 있는 캐시 라인의 번호

$$
i=j\ mod\ v\quad(i:캐시\ 세트\ 번호,\ j:주기억장치\ 블록\ 번호,\ v:\ 캐시\ 세트\ 전체\ 수)
$$

