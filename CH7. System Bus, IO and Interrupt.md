# CH7.  시스템 버스, I/O 및 인터럽트

## 7.1 시스템 버스(System Bus)

- 시스템 버스: 컴퓨터시스템의 구성 요소들(CPU, 기억장치, I/O 장치)를 상호 연결해주는 중심 통로



### 7.1.1 시스템 버스의 조직

- **버스(bus)**: 구성 요소들 간 교환할 각종 정보들을 전송하는 선(line)들로 구성
- 버스 선의 수 = 버스 폭
  - 한 번에 전송하는 데이터 비트들의 수. 기억장치 주소 비트들의 수 및 제어 신호들의 수에 따라 결정된다.
  - 소형 컴퓨터: 50~100개의 신호선들 사용
  - 중대형급 시스템: 100개 이상의 신호선들 사용
- **버스 대역폭(bus bandwidth)**: 단위 시간당 전송할 수 있는 데이터의 양(초당 몇 비트를 이동시킬 수 있는가)
  - 버스의 속도를 나타내는 척도. 
  - 버스 클록의 주기에 의해 결정
  - (예) 버스 클록의 주파수: 20MHz(클럭 주기: 50ns), 데이터 버스의 폭: 64비트(8바이트), 버스 대역폭=20MHz X 8 바이트 = 160 Mbtes/sec



$2^{10}$= K, $2^{20}$ = M, $2^{30}$ = G

#### 기능에 따른 버스의 종류

- (1) **주소 버스(address bus)**: CPU가 기억장치로 데이터 쓰기/읽기 동작을 할 때(혹은 기억장치로부터 CPU가 데이터 쓰기/읽기 동작을 할 때), 해당 기억장소를 지정하는 주소를 전송하기 위한 선들의 집합
  - 단방향 전송(unidirectional tarnsfer): CPU => 기억장치 및 I/O 제어기
  - 주소 버스의 비트 수($n$)에 의해 시스템에 접속될 수 있는 전체 기억장치의 용량이 결정됨
    - (예) 주소 버스: 16비트, 주소지정 가능한 최대 기억장소들의 수($2^{16}$=64K), 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 64K 바이트, 32-비트 단위 주소시정일 경우 최대 기억장치 용량 = 256K 바이트
    - (예) 주소 버스: 30비트, 주소지정 가능한 최대 기억장소들의 수($2^{30}$=1G), 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 1G 바이트, 32-비트 단위 주소시정일 경우 최대 기억장치 용량 = 4G 바이트
  - 직접 주소지정할 수 있는 기억장소의 단위: 바이트 혹은 단어
- (2) **데이터 버스(data bus)**: 시스템 요소들 사이에서 데이터를 전송하는데 사용되는 선들의 집합
  - 양방향 전송(bidirectional transfer)
  - 버스 폭 = CPU와 기억장치 사이에 한 번에 전송되는 비트 수
- (3) **제어 버스(control bus)**: CPU와 기억장치 및 I/O 장치 사이에 제어 신호들을 전송하는 선들의 집합



#### 제어 신호의 종류

- 일반 버스: 기억장치 및 I/O 장치와의 데이터 교환을 위한 제어신호들의 집합
  - (1) 기억장치 쓰기(memory write) 신호: 버스에 실린 데이터를 주소가 지정하는 기억장소에 저장되도록 하는 제어 신호
  - (2) 기억장치 읽기(memory read) 신호: 주소가 지정하는 기억장소의 내용을 읽어 버스에 실리게 하는 제어 신호
  - (3) I/O 쓰기(I/O write) 신호: 버스에 실린 데이터를 지정된 I/O 장치로 출력되게 하는 제어 신호
  - (4) I/O 읽기(I/O read) 신호: 지정된 I/O 장치로부터 데이터를 읽어 데이터 버스에 실리게 하는 제어 신호
- **중재 버스(arbitration bus)**: 버스 중재를 위한 제어 신호들의 집합
  - (1) 버스 요구(bus request) 신호: 버스 마스터가 버스 사용을 요구했음을 알리는 신호(BREQ)
  - (2) 버스 승인(bus grant) 신호: 버스 사용을 요구한 마스터에게 사용을 허가하는 신호(BGNT)
  - (3) 버스 사용중(bus busy) 신호: (다른 마스터가 버스를 사용하지 못하도록) 현재 버스가 사용되고 있음을 나타내는 신호(BBUSY)
  - 버스 마스터(bus master): 시스템 버스에 접속되는 요소 중, 버스 사용의 주체가 되는 요소들(CPU, 기억장치 모듈, I/O 제어기 등)
  - 버스 중재(bus arbitration): 시스템 버스에 접속된 두 개 이상의 버스 마서트들이 동시에 버스를 사용하고자 할 때, 순서대로 한 개의 마스터씩 버스를 사용할 수 있게 해주는 동작
- **인터럽트 버스(interrupt bus)**: 인터럽트 메커니즘을 위한 제어 신호들의 집합. 
  - (1) 인터럽트 요구(interrupt request) 신호: I/O 장치가 인터럽트를 요구했음을 알리는 신호(I/O 제어기가 CPU로 보냄)
  - (2) 인터럽트 확인(interrput achkowledge) 신호: CPU가 인터럽트 요구를 인식했음을 알리는 신호(CPU가 I/O 제어기로 보냄)
- **버스 클록(bus clock) 신호**: 동기식 버스에서 버스 동작들의 시간을 일치시키기 위하여 제공되는 공통 클록 신호
- 리셋 신호(reset) 신호: 모든 시스템 요소들의 동작을 초기화시키는 신호



### 7.1.2 시스템 버스의 기본 동작

- 버스의 동작 구분: (1) 읽기 동작 (2) 쓰기 동작
- **읽기 동작(read operation)**의 순서
  - (1) 버스 마스터가 버스 사용권을 획득
  - (2) 버스 마스터가 주소와 읽기 신호를 보내고, 데이터가 전송되어 올 때까지 대기
- **쓰기 동작(write operation)**의 순서
  - (1) 버스 마스터가 버스 사용권 힉득
  - (2) 버스를 통하여 주소와 데이터 및 쓰기 신호 전송
- 버스 동작들이 발생하는 시간에 따른 버스의 분류
  - (1) **동기식 버스(synchronous bus)**: 모든 동작들이 공통의 버스 클럭을 기준으로 발생
  - (2) **비동기식 버스(asynchronous bus)**: 버스 동작들이 다른 버스 동작의 발생 여부에 따라 발생



이미지??



#### 동기식 버스와 비동기식 버스의 장단점

- 동기식 버스
  - (장점) 인터페이스 회로가 간단하다(버스 클럭을 기준으로 동작하기 때문에)
  - (단점) 버스 클럭의 주기가 가장 오래 걸리는 버스 동작의 소요 시간을 기준으로 결정되므로, 소요 시간이 짧으면 동작이 완료된 후에도 대기할 수도 있음.
- 비동기식 버스
  - (장점) 동기식 버스의 단점이 없음
  - (단점) 인터페이스 회로가 복잡하다(다른 버스의 동작을 감지하여 연속적으로 동작이 이루어지므로)



## 7.2 버스 중재(bus arbitration)

- **버스 경합(bus contnetion)**: 한 개의 시스템 버스에 접속된 여러 개의 버스 마스터들이 동시에 버스 사용을 요구하는 현상
- **버스 중재(bus arbitration)**: 버스 경합이 발생할 경우, 특정 기준에 따라 버스 마스터들 중 하나를 선택하여 버스를 사용할 수 있기 해주는 동작
- **버스 중재기(bus arbiter)**: 버스를 중재하는 하드웨어 모듈



### 버스 중재 방식의 분류

- 제어 신호(버스 요구/승인 신호)의 연결 구조에 따른 분류
  - (1) **병렬 중재 방식(parallel arbitration scheme)**: 각 버스 마스터들이 독립적인 버스 요구 신호를 발생, 별도의 버스 승인 신호를 받음.
    - 버스 마스터들의 수와 버스 요구/승인 신호 선의 개수가 같다.
  - (2) **직렬 중재 방식(serial arbitration scheme)**: 버스 요구/승인 신호 선이 각각 한 개씩만 존재, 각 신호 선을 버스 마스터들 간에 직렬로 연결
- 버스 중재기의 위치에 따른 분류
  - (1) 중앙집중식 중재 방식(centralized arbitration scheme): 시스템 내에 하나의 버스 중재기가 존재, 버스 마스터들이 버스 요구 신호를 발생시키며 중재기는 중재 원칙에 따라 선택한 버스 마스터에게 승인 신호를 발생
  - (2) **분산식 중재 방식(decentralized arbitration scheme)**:  여러 개의 버스 중재기가 존재(일반적으로 각 버스 마스터마다 하나의 중재기), 버스 중재 동작이 각 마스터의 중재기에 의하여 이루어진다.
- 우선순위에 따른 분류
  - (1) **고정-우선순위 방식(fixed-prioirty scheme)**: 버스 마스터의 우선순위가 고정
  - (2) **가변-우선순위 방식(dynamic-prioirty scheme)**: 우선순위를 변경할 수 있음.



### 7.2.1 병렬 중재 방식

- **중앙집중식 고정-우선순위 방식(CPA; centralized parallel arbitration)**:  모든 버스 마스터들이 하나의 버스 중재기에 병렬 접속
  - 중재기와 가장 가까이 위치한 버스 마스터가 가장 높은 우선순위를 가진다.
  - 예) 1이 버스를 사용중일 때, 3이 버스 사용을 요구한 경우
    - 3이 BREQ3 신호를 세트(버스 사용 요구)
    - 버스 중재기가 3에게 BGNT3 신호를 세트(버스 사용 허용)
    - 1이 버스 사용을 끜내고 BBUSY 신호를 해제
    - 3이 BBUSY 신호를 세트, 버스 사용을 시작(BREQ3과 BGNT3 해제)

이미지?? 시간 흐름도

이미지?? 내부 회로도

- **분산식 고정-우선순위 방식**: 모든 버스 마스터들이 중재기를 한 개씩 가진다.
  - 동작 원리
    - 각 중재기는 자신보다 더 높은 우선순위를 가진 마스터들의 버스 요구 신호를 받아 검사, 그들이 버스 사용 요구 하지 않은 경우에만 자신의 버스 마스터로 버스 승인 신호 세트
    - 승인 신호를 받은 버스 마스터는 BBUSY 신호를 검사하여, 비활성화 상태(다른 마스터가 버스를 사용하지 않은 상태)인 경우 버스 사용을 시작한다.
  - (장점) 중앙집중식에 비해 중재 회로가 간단하여 동작 속도가 빠르다.
  - (단점) 고장을 일으킨 중재기를 찾아내는 방법이 복잡하고, 한 중재기의 고장이 전체 시스템의 동작에 영향을 미칠 수 있다.

이미지?? 존재 방식의 구성도

- **가변 우선순위 방식**: 시스템의 상태에 따라 각 버스 마스터들의 우선순위를 계속 변화시키는 방식
  - (장점) 모든 마스터들이 공정하게 버스를 사용할 수 있다.
  - (단점) 중재 회로가 복잡하다.
  - 임의 우선순위 방식(random priority): 각 중재 동작이 끝날 때마다 우선순위를 임의로 결정
  - 동등 우선순위 방식(equal prioirty): 모든 마스터들이 동등한 우선순위를 가지며, FIFO 알고리즘 사용
  - 최소-최근 사용(LRU; Least-Recently Used) 방식: 최근 가장 오랫동안 버스를 사용하지 않은 버스 마스터에게 최상위 우선순위 할당
    - (단점) 회로가 매우 복잡하다.
  - 회전 우선순위(rotating prioirty) 방식
    - 방법 (1)  중재 동작이 끝날 떄마다 모든 마스터들의 우선순위가 한 단계씩 낮아지고, 가장 우선순위가 낮았던 마스터가 최상위 우선순위를 가지도록 하는 방법
    - 방법 (2) **Acceptance-dependent식 회전 우선순위 방식**:버스 사용 승인을 받은 마스터는 최하위 우선순위를 가지며, 바로 다음에 위치한 마스터가 최상위 우선순위를 가지도록 하는 방법

RPA(ratotaionl prioirty arbitration) 이미지??



### 7.2.2 직렬 중재 방식

- **중앙집중식 직렬 중재 방식(CSA; centrailized serial arbitration)**: 하나의 중재 신호 선에 의하여 모든 버스 마스터들이 직렬로 연결된 데이지 체인(daisy chain) 형태
  - 버스 승인 신호(BGNT)선이 연결된 순서대로 우선순위
  - 동작 원리
    - 한 개 이상의 버스 마스터가 버스 사용을 요구하면 공통의 BREQ 신호 세트
    - 버스 중재기: 데이지 체인의 첫번째에 접속된 마스터로 BGNT 전송
    - BGNT를 받은 마스터: 버스 사용을 요구한 상태라면, 버스 사용권을 가짐. 버스 사용을 요구하지 않은 상태라면, BGNT를 다음에 연결된 마스터로 보냄
    - BGNT는 버스를 요구한 마스터에게 도달할 때까지 계속 통과

이미지??

- **분산식 직렬 중재 방식(DSA; decentrailized serial  arbiration)**: 데이지-체인 버스 승인 신호(DBGNT)선으로 버스 중재기들을 순환형(circular)으로 접속
  - 동작 원리
    - 버스 사용권을 부여 받은 마스터가 버스 사용을 시작하는 순간, 해당 마스터의 중재기는 자신의 오른쪽에 위치한 마스터의 중재기로 접속된 DBGNT 신호를 세트
    - 그 마스터가 버스 사용을 신청하고 대기하던 중인 경우, 중재기는 DBGNT 신호를 받아 BGNT 신호를 마스터 전송. 대기하던 중이 아니라면, 신호를 오른쪽의 중재기로 통과시킴. 이 과정을 버스를 요구한 마스터에 도달할 때까지 반복
  - 각 마스터의 우선순위가 계속 변화한다.
    - 버스 사용 승인을 받으면 다음 중재 동작에서는 최하위 우선순위를 가진다.
    - 버스를 사용한 마스터의 바로 우측에 있는 마스터가 최상위 우선순위를 가진다.
    - 순환형 구조에서 DBGNT 신호가 연결된 순서대로 우선순위가 결정된다.
  - (단점) 어느 한 지점에서 결함이 발생해도 전체 시스템의 동작 중단



### 7.2.3 폴링 방식

- **폴링 방식(polling scheme)**의 원리
  - 버스 사용을 원하는 마스터가 있는지 버스 중재기가 주기적으로 검사하여 사용 승인 여부를 결정

이미지?? 하드웨어 폴링 방식 구성도

- (1) **하드웨어 폴링 방식**: 버스 중재기와 각 버스 마스터 간에 별도의 폴링 선(pollling line)이 존재
  - 2진 코드화된 폴링 주소(binary encoded polling address)를 이용하면, 폴링 선의 수가 $log_2N$개로 감소
  - 공통의 BREQ 선과 BBUSY 선이 한 개씩 존재
  - 동작 순서
    - 중재기는 폴링 주소를 발생, 검사할 마스터를 지정하고 버스 사용을 원하는 검사
    - 지정된 마스터가 버스 사용을 원하는 경우 BREQ 신호를 세트
    - BREQ 신호가 세트되면, 중재기는 현재 검사 중인 마스터에게 버스 사용 허용, 그렇지 않으면 다음 마스터들에 대한 검사를 순서대로 진행
  - 우선순위 결정: 중재기가 마스터를 검사하는 순서에 의해 우선순위 결정, 검사할 마스터의 번호는 2진 타운터(binary counter)를 이용하여 발생
  - (장점) 속도가 빠르다.
  - (단점) 우선순위의 변경이 어렵다.
- (2) **소프트웨어 폴링 방식**: 버스 중재기 내의 프로세서가 폴링의 순서와 과정을 관장한다.
  - (장점) 우선순위의 변경이 용이하다.
  - (단점) 프로그램을 실행해야 하므로 하드웨어 방식에 비해 속도가 더 느리다.

