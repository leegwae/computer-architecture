# CH7.  시스템 버스, I/O 및 인터럽트

## 7.1 시스템 버스(System Bus)

- 시스템 버스: 컴퓨터시스템의 구성 요소들(CPU, 기억장치, I/O 장치)를 상호 연결해주는 중심 통로



### 7.1.1 시스템 버스의 조직

- **버스(bus)**: 구성 요소들 간 교환할 각종 정보들을 전송하는 선(line)들로 구성
- 버스 선의 수 = 버스 폭
  - 한 번에 전송하는 데이터 비트들의 수. 기억장치 주소 비트들의 수 및 제어 신호들의 수에 따라 결정된다.
  - 소형 컴퓨터: 50~100개의 신호선들 사용
  - 중대형급 시스템: 100개 이상의 신호선들 사용
- **버스 대역폭(bus bandwidth)**: 단위 시간당 전송할 수 있는 데이터의 양(초당 몇 비트를 이동시킬 수 있는가)
  - 버스의 속도를 나타내는 척도. 
  - 버스 클록의 주기에 의해 결정
  - (예) 버스 클록의 주파수: 20MHz(클럭 주기: 50ns), 데이터 버스의 폭: 64비트(8바이트), 버스 대역폭=20MHz X 8 바이트 = 160 Mbtes/sec



$2^{10}$= K, $2^{20}$ = M, $2^{30}$ = G

#### 기능에 따른 버스의 종류

- (1) **주소 버스(address bus)**: CPU가 기억장치로 데이터 쓰기/읽기 동작을 할 때(혹은 기억장치로부터 CPU가 데이터 쓰기/읽기 동작을 할 때), 해당 기억장소를 지정하는 주소를 전송하기 위한 선들의 집합
  - 단방향 전송(unidirectional tarnsfer): CPU => 기억장치 및 I/O 제어기
  - 주소 버스의 비트 수($n$)에 의해 시스템에 접속될 수 있는 전체 기억장치의 용량이 결정됨
    - (예) 주소 버스: 16비트, 주소지정 가능한 최대 기억장소들의 수($2^{16}$=64K), 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 64K 바이트, 32-비트 단위 주소시정일 경우 최대 기억장치 용량 = 256K 바이트
    - (예) 주소 버스: 30비트, 주소지정 가능한 최대 기억장소들의 수($2^{30}$=1G), 바이트 단위 주소지정일 경우 최대 기억장치 용량 = 1G 바이트, 32-비트 단위 주소시정일 경우 최대 기억장치 용량 = 4G 바이트
  - 직접 주소지정할 수 있는 기억장소의 단위: 바이트 혹은 단어
- (2) **데이터 버스(data bus)**: 시스템 요소들 사이에서 데이터를 전송하는데 사용되는 선들의 집합
  - 양방향 전송(bidirectional transfer)
  - 버스 폭 = CPU와 기억장치 사이에 한 번에 전송되는 비트 수
- (3) **제어 버스(control bus)**: CPU와 기억장치 및 I/O 장치 사이에 제어 신호들을 전송하는 선들의 집합



#### 제어 신호의 종류

- 일반 버스: 기억장치 및 I/O 장치와의 데이터 교환을 위한 제어신호들의 집합
  - (1) 기억장치 쓰기(memory write) 신호: 버스에 실린 데이터를 주소가 지정하는 기억장소에 저장되도록 하는 제어 신호
  - (2) 기억장치 읽기(memory read) 신호: 주소가 지정하는 기억장소의 내용을 읽어 버스에 실리게 하는 제어 신호
  - (3) I/O 쓰기(I/O write) 신호: 버스에 실린 데이터를 지정된 I/O 장치로 출력되게 하는 제어 신호
  - (4) I/O 읽기(I/O read) 신호: 지정된 I/O 장치로부터 데이터를 읽어 데이터 버스에 실리게 하는 제어 신호
- **중재 버스(arbitration bus)**: 버스 중재를 위한 제어 신호들의 집합
  - (1) 버스 요구(bus request) 신호: 버스 마스터가 버스 사용을 요구했음을 알리는 신호(BREQ)
  - (2) 버스 승인(bus grant) 신호: 버스 사용을 요구한 마스터에게 사용을 허가하는 신호(BGNT)
  - (3) 버스 사용중(bus busy) 신호: (다른 마스터가 버스를 사용하지 못하도록) 현재 버스가 사용되고 있음을 나타내는 신호(BBUSY)
  - 버스 마스터(bus master): 시스템 버스에 접속되는 요소 중, 버스 사용의 주체가 되는 요소들(CPU, 기억장치 모듈, I/O 제어기 등)
  - 버스 중재(bus arbitration): 시스템 버스에 접속된 두 개 이상의 버스 마서트들이 동시에 버스를 사용하고자 할 때, 순서대로 한 개의 마스터씩 버스를 사용할 수 있게 해주는 동작
- **인터럽트 버스(interrupt bus)**: 인터럽트 메커니즘을 위한 제어 신호들의 집합. 
  - (1) 인터럽트 요구(interrupt request) 신호: I/O 장치가 인터럽트를 요구했음을 알리는 신호(I/O 제어기가 CPU로 보냄)
  - (2) 인터럽트 확인(interrput achkowledge) 신호: CPU가 인터럽트 요구를 인식했음을 알리는 신호(CPU가 I/O 제어기로 보냄)
- **버스 클록(bus clock) 신호**: 동기식 버스에서 버스 동작들의 시간을 일치시키기 위하여 제공되는 공통 클록 신호
- 리셋 신호(reset) 신호: 모든 시스템 요소들의 동작을 초기화시키는 신호



### 7.1.2 시스템 버스의 기본 동작

- 버스의 동작 구분: (1) 읽기 동작 (2) 쓰기 동작
- **읽기 동작(read operation)**의 순서
  - (1) 버스 마스터가 버스 사용권을 획득
  - (2) 버스 마스터가 주소와 읽기 신호를 보내고, 데이터가 전송되어 올 때까지 대기
- **쓰기 동작(write operation)**의 순서
  - (1) 버스 마스터가 버스 사용권 힉득
  - (2) 버스를 통하여 주소와 데이터 및 쓰기 신호 전송
- 버스 동작들이 발생하는 시간에 따른 버스의 분류
  - (1) **동기식 버스(synchronous bus)**: 모든 동작들이 공통의 버스 클럭을 기준으로 발생
  - (2) **비동기식 버스(asynchronous bus)**: 버스 동작들이 다른 버스 동작의 발생 여부에 따라 발생



이미지??



#### 동기식 버스와 비동기식 버스의 장단점

- 동기식 버스
  - (장점) 인터페이스 회로가 간단하다(버스 클럭을 기준으로 동작하기 때문에)
  - (단점) 버스 클럭의 주기가 가장 오래 걸리는 버스 동작의 소요 시간을 기준으로 결정되므로, 소요 시간이 짧으면 동작이 완료된 후에도 대기할 수도 있음.
- 비동기식 버스
  - (장점) 동기식 버스의 단점이 없음
  - (단점) 인터페이스 회로가 복잡하다(다른 버스의 동작을 감지하여 연속적으로 동작이 이루어지므로)



## 7.2 버스 중재(bus arbitration)

- **버스 경합(bus contnetion)**: 한 개의 시스템 버스에 접속된 여러 개의 버스 마스터들이 동시에 버스 사용을 요구하는 현상
- **버스 중재(bus arbitration)**: 버스 경합이 발생할 경우, 특정 기준에 따라 버스 마스터들 중 하나를 선택하여 버스를 사용할 수 있기 해주는 동작
- **버스 중재기(bus arbiter)**: 버스를 중재하는 하드웨어 모듈



### 버스 중재 방식의 분류

- 제어 신호(버스 요구/승인 신호)의 연결 구조에 따른 분류
  - (1) **병렬 중재 방식(parallel arbitration scheme)**: 각 버스 마스터들이 독립적인 버스 요구 신호를 발생, 별도의 버스 승인 신호를 받음.
    - 버스 마스터들의 수와 버스 요구/승인 신호 선의 개수가 같다.
  - (2) **직렬 중재 방식(serial arbitration scheme)**: 버스 요구/승인 신호 선이 각각 한 개씩만 존재, 각 신호 선을 버스 마스터들 간에 직렬로 연결
- 버스 중재기의 위치에 따른 분류
  - (1) 중앙집중식 중재 방식(centralized arbitration scheme): 시스템 내에 하나의 버스 중재기가 존재, 버스 마스터들이 버스 요구 신호를 발생시키며 중재기는 중재 원칙에 따라 선택한 버스 마스터에게 승인 신호를 발생
  - (2) **분산식 중재 방식(decentralized arbitration scheme)**:  여러 개의 버스 중재기가 존재(일반적으로 각 버스 마스터마다 하나의 중재기), 버스 중재 동작이 각 마스터의 중재기에 의하여 이루어진다.
- 우선순위에 따른 분류
  - (1) **고정-우선순위 방식(fixed-prioirty scheme)**: 버스 마스터의 우선순위가 고정
  - (2) **가변-우선순위 방식(dynamic-prioirty scheme)**: 우선순위를 변경할 수 있음.



### 7.2.1 병렬 중재 방식

- **중앙집중식 고정-우선순위 방식(CPA; centralized parallel arbitration)**:  모든 버스 마스터들이 하나의 버스 중재기에 병렬 접속
  - 중재기와 가장 가까이 위치한 버스 마스터가 가장 높은 우선순위를 가진다.
  - 예) 1이 버스를 사용중일 때, 3이 버스 사용을 요구한 경우
    - 3이 BREQ3 신호를 세트(버스 사용 요구)
    - 버스 중재기가 3에게 BGNT3 신호를 세트(버스 사용 허용)
    - 1이 버스 사용을 끜내고 BBUSY 신호를 해제
    - 3이 BBUSY 신호를 세트, 버스 사용을 시작(BREQ3과 BGNT3 해제)

이미지?? 시간 흐름도

이미지?? 내부 회로도

- **분산식 고정-우선순위 방식**: 모든 버스 마스터들이 중재기를 한 개씩 가진다.
  - 동작 원리
    - 각 중재기는 자신보다 더 높은 우선순위를 가진 마스터들의 버스 요구 신호를 받아 검사, 그들이 버스 사용 요구 하지 않은 경우에만 자신의 버스 마스터로 버스 승인 신호 세트
    - 승인 신호를 받은 버스 마스터는 BBUSY 신호를 검사하여, 비활성화 상태(다른 마스터가 버스를 사용하지 않은 상태)인 경우 버스 사용을 시작한다.
  - (장점) 중앙집중식에 비해 중재 회로가 간단하여 동작 속도가 빠르다.
  - (단점) 고장을 일으킨 중재기를 찾아내는 방법이 복잡하고, 한 중재기의 고장이 전체 시스템의 동작에 영향을 미칠 수 있다.

이미지?? 존재 방식의 구성도

- **가변 우선순위 방식**: 시스템의 상태에 따라 각 버스 마스터들의 우선순위를 계속 변화시키는 방식
  - (장점) 모든 마스터들이 공정하게 버스를 사용할 수 있다.
  - (단점) 중재 회로가 복잡하다.
  - 임의 우선순위 방식(random priority): 각 중재 동작이 끝날 때마다 우선순위를 임의로 결정
  - 동등 우선순위 방식(equal prioirty): 모든 마스터들이 동등한 우선순위를 가지며, FIFO 알고리즘 사용
  - 최소-최근 사용(LRU; Least-Recently Used) 방식: 최근 가장 오랫동안 버스를 사용하지 않은 버스 마스터에게 최상위 우선순위 할당
    - (단점) 회로가 매우 복잡하다.
  - 회전 우선순위(rotating prioirty) 방식
    - 방법 (1)  중재 동작이 끝날 떄마다 모든 마스터들의 우선순위가 한 단계씩 낮아지고, 가장 우선순위가 낮았던 마스터가 최상위 우선순위를 가지도록 하는 방법
    - 방법 (2) **Acceptance-dependent식 회전 우선순위 방식**:버스 사용 승인을 받은 마스터는 최하위 우선순위를 가지며, 바로 다음에 위치한 마스터가 최상위 우선순위를 가지도록 하는 방법

RPA(ratotaionl prioirty arbitration) 이미지??



### 7.2.2 직렬 중재 방식

- **중앙집중식 직렬 중재 방식(CSA; centrailized serial arbitration)**: 하나의 중재 신호 선에 의하여 모든 버스 마스터들이 직렬로 연결된 데이지 체인(daisy chain) 형태
  - 버스 승인 신호(BGNT)선이 연결된 순서대로 우선순위
  - 동작 원리
    - 한 개 이상의 버스 마스터가 버스 사용을 요구하면 공통의 BREQ 신호 세트
    - 버스 중재기: 데이지 체인의 첫번째에 접속된 마스터로 BGNT 전송
    - BGNT를 받은 마스터: 버스 사용을 요구한 상태라면, 버스 사용권을 가짐. 버스 사용을 요구하지 않은 상태라면, BGNT를 다음에 연결된 마스터로 보냄
    - BGNT는 버스를 요구한 마스터에게 도달할 때까지 계속 통과

이미지??

- **분산식 직렬 중재 방식(DSA; decentrailized serial  arbiration)**: 데이지-체인 버스 승인 신호(DBGNT)선으로 버스 중재기들을 순환형(circular)으로 접속
  - 동작 원리
    - 버스 사용권을 부여 받은 마스터가 버스 사용을 시작하는 순간, 해당 마스터의 중재기는 자신의 오른쪽에 위치한 마스터의 중재기로 접속된 DBGNT 신호를 세트
    - 그 마스터가 버스 사용을 신청하고 대기하던 중인 경우, 중재기는 DBGNT 신호를 받아 BGNT 신호를 마스터 전송. 대기하던 중이 아니라면, 신호를 오른쪽의 중재기로 통과시킴. 이 과정을 버스를 요구한 마스터에 도달할 때까지 반복
  - 각 마스터의 우선순위가 계속 변화한다.
    - 버스 사용 승인을 받으면 다음 중재 동작에서는 최하위 우선순위를 가진다.
    - 버스를 사용한 마스터의 바로 우측에 있는 마스터가 최상위 우선순위를 가진다.
    - 순환형 구조에서 DBGNT 신호가 연결된 순서대로 우선순위가 결정된다.
  - (단점) 어느 한 지점에서 결함이 발생해도 전체 시스템의 동작 중단



### 7.2.3 폴링 방식

- **폴링 방식(polling scheme)**의 원리
  - 버스 사용을 원하는 마스터가 있는지 버스 중재기가 주기적으로 검사하여 사용 승인 여부를 결정

이미지?? 하드웨어 폴링 방식 구성도

- (1) **하드웨어 폴링 방식**: 버스 중재기와 각 버스 마스터 간에 별도의 폴링 선(pollling line)이 존재
  - 2진 코드화된 폴링 주소(binary encoded polling address)를 이용하면, 폴링 선의 수가 $log_2N$개로 감소
  - 공통의 BREQ 선과 BBUSY 선이 한 개씩 존재
  - 동작 순서
    - 중재기는 폴링 주소를 발생, 검사할 마스터를 지정하고 버스 사용을 원하는 검사
    - 지정된 마스터가 버스 사용을 원하는 경우 BREQ 신호를 세트
    - BREQ 신호가 세트되면, 중재기는 현재 검사 중인 마스터에게 버스 사용 허용, 그렇지 않으면 다음 마스터들에 대한 검사를 순서대로 진행
  - 우선순위 결정: 중재기가 마스터를 검사하는 순서에 의해 우선순위 결정, 검사할 마스터의 번호는 2진 타운터(binary counter)를 이용하여 발생
  - (장점) 속도가 빠르다.
  - (단점) 우선순위의 변경이 어렵다.
- (2) **소프트웨어 폴링 방식**: 버스 중재기 내의 프로세서가 폴링의 순서와 과정을 관장한다.
  - (장점) 우선순위의 변경이 용이하다.
  - (단점) 프로그램을 실행해야 하므로 하드웨어 방식에 비해 속도가 더 느리다.



## 7.3 I/O 장치의 접속

### 7.3.1 I/O 제어

- I/O 장치가 시스템 버스에 직접적으로 접속되지 못하는 이유
  - (1) I/O 장치들은 종류에 따라 제어 방법이 다른데, 그러한 제어 회로들을 CPU 내부에 모두 포함시키는 것이 불가능하기 때문
  - (2) I/O 장치들의 데이터 전송 속도와 CPU의 데이터 처리 속도에 비해 느리기 때문.
  - (3) I/O 장치들과 CPU가 사용하는 데이터 형식의 길이가 서로 다른 경우가 있기 때문
- 이를 해결하기 위해, 인터페이스 장치인 **I/O 제어기(I/O controller)**를 사용한다.



### 프린터 제어기의 구성

이미지?? 프린터 제어기의 내부 구성도

- **상태/제어 레지스터(status/control register)**: 내부적으로 두 개의 레지스터로 구성, 주소는 하나로 지정된다.
  - 상태 레지스터: I/O 장치의 상태와 오류 검사 결과 등을 나타내는 비트로 구성(CPU가 읽기 동작을 할 때 선택됨)
  - 제어 레지스터: CPU가 보낸 I/O 명령 단어(I/O command word)를 저장(CPU가 쓰기 동작을 할 때 선택됨)



### I/O 방식의 종류

- (1) 프로그램을 이용한 I/O(programmed I/O)
- (2) interrupt I/O
- (3) 직접 기억장치 액세스(DMA)



### 프로그램을 이용한 I/O

이미지?? 프로그램을 이용한 I/O의 흐름도

- polling: CPU가 반복적으로 I/O 장치의 상태를 검사하며 I/O 동작을 처리하는 I/O 방식
- CPU가 프린터로 데이터를 출력하는 과정
  - (1) CPU가 프린터 제어기에게 프린터의 상태를 검사하도록 요청
  - (2) 제어기는 프린터의 상태를 검사, 준비되었는지 가리키는 비트를 세트
    - 제어기가 RDY 비트를 세트
  - (3) CPU는 RDY 비트를 반복 검사, RDY 비트가 세트되었다면, 제어기로 출력 명령과 데이터를 전송
    - RDY 비트가 세트되었다면, CPU는 프린트할 데이터를 제어기의 **데이터 레지스터(data register)**에 쓰고, 명령 단어(command word)를 제어기의 제어 레지스터에 쓴다.
  - (4) 제어기는 프린트 동작을 위한 제어 신호와 데이터를 프린터로 보냄.
- (장점) 방식이 간단하고 별도의 하드웨어가 필요하지 않음.
- (단점) CPU가 I/O 동작에 직접 관여하는 동안, 다른 일을 처리할 수 없음



### 7.3.2 I/O 주소지정

- I/O 장치는 두 개의 주소(데이터 레지스터의 주소, 상태/제어 레지스터의 주소)를 가진다.
- 이 I/O 주소를 지정하는 방법
  - (1) 기억장치-사상 I/O(memory-mapped I/O)
  - (2) 분리형 I/O(isolated-I/O)



#### 7.3.2.1 기억장치-사상 I/O

- 기억장치 주소 공간의 일부를 I/O 레지스터의 주소로 할당
  - 기억장치와 I/O 레지스터들에 액세스할 때 동일한 기계 명령어를 사용할 수 있음
    - 프로그래밍에서 기억장치 관련 명령어들을 I/O 장치 제어에 사용 가능하다.
    - 예) LOAD 명령어, STORE 명령어 등
  - 기억장치 RW 신호를 I/O RW 신호로 사용할 수 있음(별도의 I/O 제어 신호가 필요하지 않음)
- (장점) 사용 가능한 명령어들이 다양하여 프로그래밍이 용이
- (단점) 기억장치 주소 공간이 감소한다.



이미지?? 기억장치-사상 I/O의 주소 공간 할당의 예

- 주소 비트가 10비트 -> 전체 기억장소들의 수 = $2^{10}=1024$
- 상위 512개 주소(0번지 ~ 511번지): 기억장치에 할당
- 하위 512개 주소(512번지 ~ 1023번지): I/O 장치들에 할당



기억장치-사상 I/O 방식을 이용한 프린터 출력 프로그램 예시



#### 7.3.2.2 분리형 I/O

- I/O 장치 주소공간과 기억장치 주소 공간이 별도로 할당
  - I/O 제어를 위하여 별도의 I/O 명령어를 사용
    - 예) IN, OUT 명령어
  - 별도의 I/O RW 신호가 필요
- (장점) 기억장치 주소 공간이 줄어들지 않음
- (단점) I/O 제어를 위하여 I/O 명령어들만 이용할 수 있으므로, 프로그래밍이 불편



이미지?? 분리형 I/O의 주소 공간 할당의 예

- 주소 비트가 10비트 -> 각각 $2^{10}$개씩 할당



분리형 I/O 방식을 이용한 프린터 출력 프로그램 예시



## 7.4 인터럽트를 이용한 I/O

- **인터럽트-구동 I/O(interrupt-driven I/O)**: 인터럽트 메거니즘을 이용하여 I/O 동작이 진행되는 동안 CPU가 다른 작업을 처리할 수 있도록 함
- (장점) 매주기 상태 비트를 검사하지 않아도 된다.
- (단점) 데이터 이동 때 CPU의 동작이 개입된다.
- 동작 순서
  - (1) CPU가 I/O 제어기에 명령을 전송, CPU는 다른 작업을 처리
  - (2) 제어기는 I/O 장치를 제어하여 I/O 명령을 수행
  - (3) I/O 명령 수행이 완료되면, 제어기는 CPU로 인터럽트 신호를 전송
  - (4) CPU는 인터럽트 신호를 받으면 즉시 원래의 프로그램으로 복귀하여 수행을 계속



?? 이미지 인터럽트-구동 I/O 방식에서의 프린터 출력 흐름도



### 인터럽트-구동 I/O의 구현 방법

- (1) 다중-인터럽트(multiple interrupt) 방식
- (2) 데이지-체인(dasiy-chain) 방식
- (3) 소프트웨어 폴링(software polling) 방식



### 7.4.1 다중-인터럽트 방식

이미지??

- 각 I/O 제어기와 CPU 사이에 별도의 인터럽트 요구(INTR; interrupt request) 선과 인터럽트 확인(INTA; interrupt acknowledge) 선을 접속
- INTA: interrupt vector(ISR의 시작 주소를 결정하는데 사용)를 보냄 (??)
- I/O 제어기 #2가 인터럽트를 요구하는 경우의 동작 순서
  - (1) I/O 제어기 #2가 INTR2 신호를 세트
  - (2) CPU는 INTA2 신호를 세트(인터럽트 요구를 인식하였음을 알림), ISR를 시작
  - (3) I/O 제어기 #2는 INTR2 신호를 해제
  - (4) CPU도 INTA2 신호를 해제
- (장점) CPU가 인터럽트를 요구한 장치를 쉽게 찾아낼 수 있음
- (단점) 하드웨어가 복잡하고, 접속 가능한 I/O 장치들의 수가 CPU의 인터럽트 요구 입력 핀의 수에 의해 제한됨
- 인터럽트 플래그(interrupt flag): ISR를 시작하는 순간 플래그를 세트하면 다른 인터럽트 요구를 받지 않지만, 플래그를 세트하지 않았다면 더 높은 우선순위의 인터럽트를 처리하러 가야함.



### 7.4.2 데이지-체인 방식

- CPU로부터 발생되는 INTA 출력 선을 I/O 제어기들에 직렬로 접속
- CPU는 누가 intrrupt를 요구했는지 알 수 없다.
- 인터럽트를 요구한 I/O 장치는 Aln(Ack In) 입력을 받는 즉시 자신의 고유 번호(ID), 즉 **인터럽트 벡터(interrupt vector)**를 데이터 버스를 통하여 CPU로 전송
- Aln 입력을 받은 I/O 장치가 인터럽트를 요구하지 않은 상태이면, 그 입력을 다음 장치로 통과(pass) 시킴.
- (장점) 하드웨어가 간단하다.
- (단점) starvation: 우선순위가 낮은 장치들이 서비스를 받지 못하고 매우 오랫동안 기다려야 하는 경우가 발생



### 7.4.3 소프트웨어 폴링 방식

- CPU가 모든 I/O 제어기들에 접속된 TEST I/O 선을 이용하여 인터럽트를 요구한 장치를 검사
  - CPU는 누가 intrrupt를 요구했는지 알 수 없으므로 검사
  - TEST I/O 신호를 이요하여 각 I/O 장치의 인터럽트 플래그가 세트되어있는지 검사
  - 검사 순서가 우선순위를 결정
- (장점) 우선순위의 변경이 용이
- (단점) 소프트웨어이므로 모든 interrupt 발생 주체를 찾기 위하여 검사하는 등 처리 시간이 오래 걸린다.

