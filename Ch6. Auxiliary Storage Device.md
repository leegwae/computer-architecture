# Ch6. 보조저장장치

## 6.1 하드 디스크(hard disk)

- **자기 디스크(magnetic hard disk; 디스크)**: 자화될 수 있는 물질로 코팅된 플라스틱 혹은 금속을 이용한 원형 평판으로 만든 저장장치

이미지??

- 하드 디스크의 주요 구성 요소
  - (1) **원형 평판(circular platter)**: 실제 정보가 저장되는 장소. 트랙(track)들로 구성되어있다.
  - (2) **헤드(head)**: 전도성 코일을 통해 표면ㅇ르 자화하여 데이터를 저장
  - (3) **디스크 팔(disk arm)**: 헤드를 이동시키는 장치
  - (4) **구동장치(actuator)**: 원형 평판 회전 및 디스크 팔 구동을 위한 모터(motor)



### 6.1.1 디스크의 구조

이미지??

- (1) **섹터(sector)**: 트랙의 분할된 각 부분. 데이터 전송 단위인 블록을 저장. 즉, 디스크가 한 번에 액세스할 수 있는 데이터 크기의 최소 단위이다.
- (2) 섹터 간 갭(inter-sector gap): 섹터들을 구분하기 위한 간격
- (3) 트랙 간 갭(inter-track gap): 트랙들을 구분하기 위한 간격. 헤드가 잘못 정렬되거나 자장이 간섭 때문에 발생하는 오류를 방지
- 초기 디스크의 경우, 표면당 트랙의 수 = 500 ~ 2000개, 트랙 당 섹터의 수 = 32개



#### 등각속도(Constant Angular Velocity; CAV) 방식

- 등각속도 방식: 트랙의 길이에 상관없이, 트랙 당 저장되는 데이터 비트 수를 모두 같게 하는 방식. 디스크가 일정한 속도로 회전하는 상태에서, 트랙의 위치에 상관없이 데이터를 동일한 비율로 액세스하게 된다.
- (장점) 읽기, 쓰기 구동장치가 간단하다.
- (단점) 바깥쪽 트랙이 안쪽 트랙보다 더 길지만 저장 밀도가 낮으므로 저장 공간을 낭비한다.



### 6.1.2 디스크 액세스 시간

- **디스크 액세스 동작의 순서**
  - (1) **탐색 시간(seek time)**: 헤드를 해당 트랙으로 이동한다.
  - (2) **회전 지연시간(rotational time)**: 원하는 섹터가 헤드 아래로 회전되어 올 때까지 대기한다.
  - (3) **데이터 전송 시간(data transfer time)**: 데이터를 전송한다.
- **디스크 액세스 시간(disk access time)**: (1) 탐색 시간 + (2) 회전 지연시간 + (3) 데이터 전송 시간 및 디스크 제어기(disk controller)에서 소요되는 시간



#### 디스크 형식화 작업(disk formatting)

이미지???

- 디스크 형식화 작업: 디스크의 구성을 검사하고, 그에 관한 정보와 트랙의 시작점, 섹터의 시작과 끝을 구분하기 위한 제어 정보 등을 디스크 상의 특정 위치에 저장하는 과정
- 트랙 형식의 예
  - 섹터 크기 = 600바이트 = 데이터 필드(512바이트) + ID 필드 + 갭 3개
  - 제어 정보(ID 필드) : 섹터를 구분하는데 필요한 식별자 또는 주소
    -  (1) SYNCH 바이트: 필드의 시작점을 나타내는 비트 패턴
    - (2) 트랙 번호: n 바이트 고정
    - (3) 헤드 번호
    - (4) 섹터 번호
    - (5) CRC(오류 검출 코드)



#### CRC(Cyclic Redundancy Check)

- CRC: 디스크로부터 데이터를 읽거나, 데이터를 통신하는 과정에서 발생하는 오류를 검출하는 순환 2진 부호를 사용하는 방식
- (송신 측) 블록 단위로 데이터를 나눈 후 각 블록 뒤에 순환 부호를 붙여 저장 후 송신.
  - 2진 다항식의 특수 계산으로 순환 부호 얻음
- (수신 측) 동일한 계산을 수행하여 동일한 순환 부호가 얻어지는지 확인
- 패리티 비트 방식보다 정교하여 오류 검출 능력이 뛰어남
- 저장장치(하드 디스크, CD-ROM, DVD) 및 각종 통신 프로토콜에서 사용



## 6.2 RAID

- 디스크의 신뢰성 문제: 디스크가 고장이 나는 문제
- **RAID(Redundant Array of Independent Disks)**: 다수의 작은 디스크를 배열 구조로 연결한 디스크 시스템
  - (1) 디스크 인터리빙 (2) CRC (3) 디스크 미러링을 통칭
- RAID의 장점
  - 데이터 분산 저장에 의한 동시 액세스(concurrent access) 가능
  - 병렬 데이터 채널에 의한 데이터 전송 속도 향상
  - 신뢰성을 향상
- RAID의 단점: MTTF가 단축됨



#### MTTF(Mean Time To Failure)

- **MTTF**: 디스크가 고장나는데 걸리는 평균 시간

$$
\mathrm{MTTF}=\frac{단일\ 디스크의\ \mathrm{MTTF}}{배열\ 내\ 디스크의\ 수}
$$



### 6.2.1 RAID 출현 배경

- 디스크 배열의 결함 허용도(fault-tolerance)를 높이기 위해 제안됨.
- 결함허용도: 고장에 대해 얼마나 강한가
- RAID의 핵심 기술: 검사 디스크(check disk)를 이용하여 오류를 검출하고 복구하는 기능 (error detection and recovery)을 추가
- 디스크 결함 발생 시 복구 절차(시스템이 정상적인 동작을 유지하고 있는 상태에서 진행)
  - (1) 해당 디스크 사용을 중단하고 시스템으로부터 분리(디스크 용량 축소)
  - (2) 검사 디스크에 저장된 정보로 원래의 데이터 복구
  - (3) 결함을 수리하고 디스크 재설치
  - (4) 시스템 재구성(원래의 디스크 용량을 회복)



#### 디스크 인터리빙(Disk Interleaving)

이미지??

- **디스크 인터리빙**: 데이터 블록들을 여러 개의 디스크들로 이루어진 디스크 배열(disk array)에 분산 저장하는 기술
- 균등한 분산 저장을 위하여 라운드-로빈(round-robin) 방식을 사용한다.
- 데이터를 병렬로 읽을 수 있다.
  - 라운드 로빈을 사용하지 않는 방식보다 데이터 액세스가 빠르다.



### 6.2.2 RAID의 종류

#### 6.2.2.1 RAID-1

- **디스크 미러링(disk mirroring)** 방식 이용: 디스크에 짝을 이루는 미러 디스크에 동일한 위치로 모든 데이터를 복사
- (장점) 완전한 결함 허용도를 제공: 가정 널리 사용한다
- (단점) 가격이 높다
- (주요 용도)
  - (1) 높은 신뢰도를 요구하는 결함허용시스템에 주로 사용한다.
  - (2) 시스템 소프트웨어 혹은 중요한 데이터 파일 저장에 사용한다.



#### 6.2.2.2 RAID-3

이미지??

- 패리티(parity) 방식 이용
  - 패리티 비트: $p=b1\oplus b2\oplus b3 \oplus b4$
  - 연산 결과: 1의 개수가 짝수면 p =  0. 홀수면 p =1  
- 결함 발생 시 데이터 복구 방법(예: $b2$ 결함 발생시)
  - $b2=p\oplus b1\oplus b3 \oplus b4$
- (장점)
  - (1) 병렬로 읽기/쓰기가 가능하다: 디스크 액세스 속도 향상
  - (2) 적은 수의 패리티 디스크로 결함허용도를 제공한다.
- (단점) 쓰기 동작 때마다 패리티 비트를 갱신해야 한다: 시간 지연이 발생한다.



#### 6.2.2.3 RAID-2

이미지??

-  **비트-단위 인터리빙**: 데이터를 비트 단위로 각 디스크에 분산 저장하는 방식
  - **해밍 코드(hamming code)**를 이용하여 오류 검출 및 정정
  - (장점) 디스크 미러링에 가까운 결함허용도 제공
  - (단점)
    - (1) 필요한 검사 디스크들의 수가 많아 가격이 비싸다.
    - (2) 많은 읽기/쓰기 동작이 필요하다.
  - (주요 용도) 오류가 많이 발생하는 환경에서 사용한다.



#### 6.2.2.4 RAID-4

이미지??

- **블록 단위 인터리빙** 방식을 사용한다.

- 데이터 디스크들의 동일한 위치에 있는 블록들에 대한 패리티 블록을 패리티 디스크에 저장

- (단점) 한 번의 쓰기 동작을 위해 패리티 디스크를 두 번 액세스: 병목 현상 발생

- 데이터 블록 쓰기 과정: 두번째 디스크에 저장된 블록 $B2$를 $B2^`$로 갱신하는 경우

  - 새로운 패리티 블록 $P^`=B1\oplus B2^`\oplus B3\oplus B4$

    - 세 번의 디스크 읽기: $B1, B3, B4$ 읽음
    - 두 번의 디스크 쓰기: 새로운 데이터 쓰기, 패리티 쓰기

  - 디스크 액세스 횟수의 최소화 방법

    이미지??

    - 네 번의 디스크 액세스: 원래 데이터 읽기, 원래 패리티 읽기, (새로운 패리티 계산), 새로운 데이터 쓰기,  새로운 패리티 쓰기



#### 6.2.2.5 RAID-5

- RAID-4의 문제점을 보완
- 패리티 블록들을 라운드-로빈 방식으로 분산 저장
- (장점)
  - (1) 패리티 디스크에 대한 병목 현상 해소
  - (2) 쓰기 동작을 병렬로 수행할 수 있다: 데이터 디스크의 수 $G$에 대해, 최대 $(G+1)/2$번의 쓰기 동작을 병렬로 수행할 수 있다.
- (단점)
  - (1) 어떤 데이터를 수정하더라도 패리티 디스크도 수정해야한다: 패리티 디스크들에 대해 균등한 액세스가 이루어지지 않는다.
  - (2) **작은 쓰기 문제(small write problem)**: 한 블록을 디스크에 쓰는 경우 네 번의 디스크 액세스가 필요하여 성능이 저하되는 문제
    - 한 비트만 수정해도 패리티 디스크를 수정해야한다(RAID-4에서도 문제)



#### 큰 쓰기(large write)

- 큰 쓰기: 디스크 수보다 더 많은 블록들로 이루어진 파일을 한꺼번에 저장 혹은 갱신하는 것
- 패리티 블록을 미리 계싼하여, 새로운 데이터 및 패리티 블록을 한 번씩만 쓰면 된다.



#### RAID-1과 RAID-5의 비교

- RAID-1: 읽기와 작은 쓰기가 많은 환경에 적합
- RAID-5: 용량과 비용을 중요시하거나 큰 쓰기 요구가 많은 환경에 적합
- 가격 대 성능비 측면: RAID-5 우수